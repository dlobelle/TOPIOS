{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "# 29/01/20- Based on Kooi_North Pacific_1D.py but using NEMO-MEDUSA profiles (now grid size is no longer 2x2 since 1/12 so can use min lons and lats and then index + 1 for 2x2 grid)\n",
    "\n",
    "from parcels import FieldSet, ParticleSet, JITParticle, ScipyParticle, AdvectionRK4_3D, AdvectionRK4, ErrorCode, ParticleFile, Variable, Field, NestedField, VectorField, timer #polyTEOS10_bsq #seawaterdensity\n",
    "from datetime import timedelta as delta\n",
    "from datetime import  datetime\n",
    "import numpy as np\n",
    "import math\n",
    "from glob import glob\n",
    "import os\n",
    "import xarray as xr\n",
    "import sys\n",
    "import time as timelib\n",
    "import matplotlib.pyplot as plt\n",
    "import warnings\n",
    "import pickle                                                      \n",
    "import matplotlib.ticker as mtick\n",
    "import pandas as pd \n",
    "import operator\n",
    "from numpy import *\n",
    "import scipy.linalg\n",
    "import math as math\n",
    "warnings.filterwarnings(\"ignore\")\n",
    "\n",
    "minlat = 36\n",
    "minlon = -160\n",
    "\n",
    "simdays = 10\n",
    "time0 = 0\n",
    "simhours = 1\n",
    "simmins = 30\n",
    "secsdt = 10\n",
    "hrsoutdt = 10\n",
    "\n",
    "#------ CHOOSE -----\n",
    "rho_pl = 920.                 # density of plastic (kg m-3): DEFAULT FOR FIG 1: 920 but full range is: 840, 920, 940, 1050, 1380 (last 2 are initially non-buoyant)\n",
    "r_pl = \"1e-04\"                # radius of plastic (m): DEFAULT FOR FIG 1: 10-3 to 10-6 included but full range is: 10 mm to 0.1 um or 10-2 to 10-7\n",
    "\n",
    "\"\"\" Defining the particle class \"\"\"\n",
    "\n",
    "class plastic_particle(JITParticle): #ScipyParticle\n",
    "    u = Variable('u', dtype=np.float32,to_write=False)\n",
    "    v = Variable('v', dtype=np.float32,to_write=False)\n",
    "    w = Variable('w', dtype=np.float32,to_write=True)\n",
    "    temp = Variable('temp',dtype=np.float32,to_write=False)\n",
    "    density = Variable('density',dtype=np.float32,to_write=True)\n",
    "    #aa = Variable('aa',dtype=np.float32,to_write=True)\n",
    "    tpp = Variable('tpp',dtype=np.float32,to_write=False) # mu_aa\n",
    "    d_phy = Variable('d_phy',dtype=np.float32,to_write=False)\n",
    "    nd_phy = Variable('nd_phy',dtype=np.float32,to_write=False)    \n",
    "    kin_visc = Variable('kin_visc',dtype=np.float32,to_write=False)\n",
    "    sw_visc = Variable('sw_visc',dtype=np.float32,to_write=False)    \n",
    "    a = Variable('a',dtype=np.float32,to_write=True)\n",
    "    vs = Variable('vs',dtype=np.float32,to_write=True)    \n",
    "    \n",
    "\"\"\"functions and kernals\"\"\"\n",
    "\n",
    "def DeleteParticle(particle, fieldset, time):\n",
    "    \"\"\"Kernel for deleting particles if they are out of bounds.\"\"\"\n",
    "    print('particle is deleted') \n",
    "    #print(particle.lon, particle.lat, particle.depth)\n",
    "    particle.delete()\n",
    "\n",
    "def getclosest_ij(lats,lons,latpt,lonpt):     \n",
    "    \"\"\"Function to find the index of the closest point to a certain lon/lat value.\"\"\"\n",
    "    dist_sq = (lats-latpt)**2 + (lons-lonpt)**2                 # find squared distance of every point on grid\n",
    "    minindex_flattened = dist_sq.argmin()                       # 1D index of minimum dist_sq element\n",
    "    return np.unravel_index(minindex_flattened, lats.shape)     # Get 2D index for latvals and lonvals arrays from 1D index\n",
    "\n",
    "# def Sink(particle, fieldset, time):\n",
    "#     \"\"\"Kernal for sinking (to be changed with Kooi equation later)\"\"\"\n",
    "#     #print(particle.depth)\n",
    "# #    particle.depth = 30#particle.depth + fieldset.sinkspeed * particle.dt\n",
    "# #    w1 = fieldset.W[time, particle.depth, particle.lat, particle.lon]  \n",
    "#     sp = 10./86400. #The sinkspeed m/day (CAN CHANGE THIS LATER- in Kooi et al. 2017 for particle of 0.1mm = 100 m d-1)\n",
    "#     particle.depth += sp * particle.dt #(sp/(24*60*60)) * particle.dt # m/s : 1e-3\n",
    "\n",
    "def AdvectionRK4_3D_vert(particle, fieldset, time):\n",
    "    \"\"\"Advection of particles using fourth-order Runge-Kutta integration including vertical velocity.\n",
    "    Function needs to be converted to Kernel object before execution\"\"\"\n",
    "    (w1) = fieldset.W[time, particle.depth, particle.lat, particle.lon]\n",
    "    #lon1 = particle.lon + u1*.5*particle.dt\n",
    "    #lat1 = particle.lat + v1*.5*particle.dt\n",
    "    dep1 = particle.depth + w1*.5*particle.dt\n",
    "    (w2) = fieldset.W[time + .5 * particle.dt, dep1, particle.lat, particle.lon]\n",
    "    #lon2 = particle.lon + u2*.5*particle.dt\n",
    "    #lat2 = particle.lat + v2*.5*particle.dt\n",
    "    dep2 = particle.depth + w2*.5*particle.dt\n",
    "    (w3) = fieldset.W[time + .5 * particle.dt, dep2, particle.lat, particle.lon]\n",
    "    #lon3 = particle.lon + u3*particle.dt\n",
    "    #lat3 = particle.lat + v3*particle.dt\n",
    "    dep3 = particle.depth + w3*particle.dt\n",
    "    (w4) = fieldset.W[time + particle.dt, dep3, particle.lat, particle.lon]\n",
    "    #particle.lon += particle.lon #(u1 + 2*u2 + 2*u3 + u4) / 6. * particle.dt\n",
    "    #particle.lat += particle.lat #lats[1,1] #(v1 + 2*v2 + 2*v3 + v4) / 6. * particle.dt\n",
    "    particle.depth += (w1 + 2*w2 + 2*w3 + w4) / 6. * particle.dt\n",
    "\n",
    "def polyTEOS10_bsq(particle, fieldset, time):\n",
    "    # calculates density based on the polyTEOS10-bsq algorithm from Appendix A.2 of\n",
    "    # https://www.sciencedirect.com/science/article/pii/S1463500315000566\n",
    "    # requires fieldset.abs_salinity and fieldset.cons_temperature Fields in the fieldset\n",
    "    # and a particle.density Variable in the ParticleSet\n",
    "    #\n",
    "    # References:\n",
    "    #  Roquet, F., Madec, G., McDougall, T. J., Barker, P. M., 2014: Accurate\n",
    "    #   polynomial expressions for the density and specific volume of\n",
    "    #   seawater using the TEOS-10 standard. Ocean Modelling.\n",
    "    #  McDougall, T. J., D. R. Jackett, D. G. Wright and R. Feistel, 2003:\n",
    "    #   Accurate and computationally efficient algorithms for potential\n",
    "    #   temperature and density of seawater.  Journal of Atmospheric and\n",
    "    #   Oceanic Technology, 20, 730-741.\n",
    "\n",
    "    Z = - particle.depth  # note: use negative depths!\n",
    "    SA = fieldset.abs_salinity[time, particle.depth, particle.lat, particle.lon]\n",
    "    CT = fieldset.cons_temperature[time, particle.depth, particle.lat, particle.lon]\n",
    "\n",
    "    SAu = 40 * 35.16504 / 35\n",
    "    CTu = 40\n",
    "    Zu = 1e4\n",
    "    deltaS = 32\n",
    "    R000 = 8.0189615746e+02\n",
    "    R100 = 8.6672408165e+02\n",
    "    R200 = -1.7864682637e+03\n",
    "    R300 = 2.0375295546e+03\n",
    "    R400 = -1.2849161071e+03\n",
    "    R500 = 4.3227585684e+02\n",
    "    R600 = -6.0579916612e+01\n",
    "    R010 = 2.6010145068e+01\n",
    "    R110 = -6.5281885265e+01\n",
    "    R210 = 8.1770425108e+01\n",
    "    R310 = -5.6888046321e+01\n",
    "    R410 = 1.7681814114e+01\n",
    "    R510 = -1.9193502195e+00\n",
    "    R020 = -3.7074170417e+01\n",
    "    R120 = 6.1548258127e+01\n",
    "    R220 = -6.0362551501e+01\n",
    "    R320 = 2.9130021253e+01\n",
    "    R420 = -5.4723692739e+00\n",
    "    R030 = 2.1661789529e+01\n",
    "    R130 = -3.3449108469e+01\n",
    "    R230 = 1.9717078466e+01\n",
    "    R330 = -3.1742946532e+00\n",
    "    R040 = -8.3627885467e+00\n",
    "    R140 = 1.1311538584e+01\n",
    "    R240 = -5.3563304045e+00\n",
    "    R050 = 5.4048723791e-01\n",
    "    R150 = 4.8169980163e-01\n",
    "    R060 = -1.9083568888e-01\n",
    "    R001 = 1.9681925209e+01\n",
    "    R101 = -4.2549998214e+01\n",
    "    R201 = 5.0774768218e+01\n",
    "    R301 = -3.0938076334e+01\n",
    "    R401 = 6.6051753097e+00\n",
    "    R011 = -1.3336301113e+01\n",
    "    R111 = -4.4870114575e+00\n",
    "    R211 = 5.0042598061e+00\n",
    "    R311 = -6.5399043664e-01\n",
    "    R021 = 6.7080479603e+00\n",
    "    R121 = 3.5063081279e+00\n",
    "    R221 = -1.8795372996e+00\n",
    "    R031 = -2.4649669534e+00\n",
    "    R131 = -5.5077101279e-01\n",
    "    R041 = 5.5927935970e-01\n",
    "    R002 = 2.0660924175e+00\n",
    "    R102 = -4.9527603989e+00\n",
    "    R202 = 2.5019633244e+00\n",
    "    R012 = 2.0564311499e+00\n",
    "    R112 = -2.1311365518e-01\n",
    "    R022 = -1.2419983026e+00\n",
    "    R003 = -2.3342758797e-02\n",
    "    R103 = -1.8507636718e-02\n",
    "    R013 = 3.7969820455e-01\n",
    "    ss = math.sqrt((SA + deltaS) / SAu)\n",
    "    tt = CT / CTu\n",
    "    zz = -Z / Zu\n",
    "    rz3 = R013 * tt + R103 * ss + R003\n",
    "    rz2 = (R022 * tt + R112 * ss + R012) * tt + (R202 * ss + R102) * ss + R002\n",
    "    rz1 = (((R041 * tt + R131 * ss + R031) * tt + (R221 * ss + R121) * ss + R021) * tt + ((R311 * ss + R211) * ss + R111) * ss + R011) * tt + (((R401 * ss + R301) * ss + R201) * ss + R101) * ss + R001\n",
    "    rz0 = (((((R060 * tt + R150 * ss + R050) * tt + (R240 * ss + R140) * ss + R040) * tt + ((R330 * ss + R230) * ss + R130) * ss + R030) * tt + (((R420 * ss + R320) * ss + R220) * ss + R120) * ss + R020) \n",
    "           * tt + ((((R510 * ss + R410) * ss + R310) * ss + R210) * ss + R110) * ss + R010) * tt + (((((R600 * ss + R500) * ss + R400) * ss + R300) * ss + R200) * ss + R100) * ss + R000\n",
    "    particle.density = ((rz3 * zz + rz2) * zz + rz1) * zz + rz0\n",
    "    \n",
    "def Profiles(particle, fieldset, time):  \n",
    "    particle.temp = fieldset.cons_temperature[time, particle.depth,particle.lat,particle.lon]  \n",
    "    particle.d_phy= fieldset.d_phy[time, particle.depth,particle.lat,particle.lon]  \n",
    "    particle.nd_phy= fieldset.nd_phy[time, particle.depth,particle.lat,particle.lon] \n",
    "    particle.tpp = fieldset.tpp[time, particle.depth,particle.lat,particle.lon] \n",
    "    particle.kin_visc = fieldset.KV[time,particle.depth,particle.lat,particle.lon] \n",
    "    particle.sw_visc = fieldset.SV[time,particle.depth,particle.lat,particle.lon] \n",
    "    particle.w = fieldset.W[time,particle.depth,particle.lat,particle.lon]\n",
    "    \n",
    "def Kooi(particle,fieldset,time):  \n",
    "    # 30/01/20- for aa and mu_aa, using ratios to get ambient algal concentrations and algal growth (N:C:AA using Redfield ratio... C:N = 6.625, so N*6.625)\n",
    "    \n",
    "    # \n",
    "    min_N2cell = 2656.0e-09 #[mgN cell-1] 35339e-09 [mgC cell-1]\n",
    "    max_N2cell = 11.0e-09   #[mgN cell-1] 47.67e-09 [mgC cell-1]\n",
    "    med_N2cell = 356.04e-09\n",
    "    \n",
    "#   n0 = particle.nd_phy # mmol N m-3 \n",
    "#   n = n0*14.007 # conversion from mmol N m-3 to mg N m-3 (atomic weight of 1 mol of N = 14.007 g, so same from mmol to mg)    \n",
    "    #c = n*6.625 # conversion from mg N m-3 to mg C m-3 (Redfield ratio)\n",
    "    #c2 = c/(47.76*1e-09)\n",
    "    \n",
    "    #print(c2)\n",
    "    #if c2<0:# conversion from mg C m-3 to no. m-3\n",
    "    #    aa = 0\n",
    "    #else:\n",
    "    #    aa = c2   # should be [no m-3] to compare to Kooi model    \n",
    "    #particle.aa = aa\n",
    "    \n",
    "    \n",
    "    n0 = particle.nd_phy+particle.d_phy # mmol N m-3 \n",
    "    n = n0*14.007       # conversion from mmol N m-3 to mg N m-3 (atomic weight of 1 mol of N = 14.007 g)   \n",
    "    n2 = n/med_N2cell   # conversion from mg N m-3 to no. m-3\n",
    "    \n",
    "    if n2<0.: \n",
    "        aa = 0.\n",
    "    else:\n",
    "        aa = n2   # [no m-3] to compare to Kooi model    \n",
    "\n",
    "    mu_n0 = particle.tpp/aa    \n",
    "    mu_n = mu_n0*14.007               # conversion from mmol N m-3 d-1 to mg N m-3 d-1 (atomic weight of 1 mol of N = 14.007 g) \n",
    "    mu_n2 = mu_n/med_N2cell           # conversion from mg N m-3 d-1 to d-1\n",
    "\n",
    "    if mu_n2<0.:\n",
    "        mu_aa = 0.\n",
    "    else:\n",
    "        mu_aa = mu_n2/86400. # conversion from d-1 to s-1\n",
    "    #print(mu_aa)\n",
    "    z = particle.depth           # [m]\n",
    "    t = particle.temp            # [oC]\n",
    "    sw_visc = particle.sw_visc   # [kg m-1 s-1]\n",
    "    kin_visc = particle.kin_visc # [m2 s-1]\n",
    "    rho_sw = particle.density    # [kg m-3]   #rho_sw     \n",
    "    a = particle.a               # [no. m-2 s-1]\n",
    "    vs = particle.vs #particle.depth # [m s-1]\n",
    "\n",
    "    \n",
    "    #------ CHOOSE -----\n",
    "    rho_pl = 920.                 # density of plastic (kg m-3): DEFAULT FOR FIG 1: 920 but full range is: 840, 920, 940, 1050, 1380 (last 2 are initially non-buoyant)\n",
    "    r_pl = 1e-04                  # radius of plastic (m): DEFAULT FOR FIG 1: 10-3 to 10-6 included but full range is: 10 mm to 0.1 um or 10-2 to 10-7\n",
    "\n",
    "    #------ Constants and algal properties -----\n",
    "    g = 7.32e10/(86400.**2.)    # gravitational acceleration (m d-2), now [s-2]\n",
    "    k = 1.0306E-13/(86400.**2.) # Boltzmann constant [m2 kg d-2 K-1] now [s-2] (=1.3804E-23)\n",
    "    rho_bf = 1388.              # density of biofilm ([g m-3]\n",
    "    v_a = 2.0E-16               # Volume of 1 algal cell [m-3]\n",
    "    m_a = 0.39/86400.           # mortality rate, now [s-1]\n",
    "    r20 = 0.1/86400.            # respiration rate, now [s-1] \n",
    "    q10 = 2.                    # temperature coefficient respiration [-]\n",
    "    gamma = 1.728E5/86400.      # shear [d-1], now [s-1]\n",
    "    \n",
    "    #------ Volumes -----\n",
    "    v_pl = (4./3.)*math.pi*r_pl**3.             # volume of plastic [m3]\n",
    "    theta_pl = 4.*math.pi*r_pl**2.              # surface area of plastic particle [m2]\n",
    "    r_a = ((3./4.)*(v_a/math.pi))**(1./3.)      # radius of algae [m]\n",
    "    \n",
    "    v_bf = (v_a*a)*theta_pl                           # volume of biofilm [m3]\n",
    "    v_tot = v_bf + v_pl                               # volume of total [m3]\n",
    "    t_bf = ((v_tot*(3./(4.*math.pi)))**(1./3.))-r_pl  # biofilm thickness [m] \n",
    "    \n",
    "    \n",
    "    r_tot = r_pl + t_bf                               # total radius [m]\n",
    "    rho_tot = (r_pl**3. * rho_pl + ((r_pl + t_bf)**3. - r_pl**3.)*rho_bf)/(r_pl + t_bf)**3. # total density [kg m-3]\n",
    "    rho_tot = rho_tot\n",
    "    theta_tot = 4.*math.pi*r_tot**2.                          # surface area of total [m2]\n",
    "    d_pl = k * (t + 273.16)/(6. * math.pi * sw_visc * r_tot)  # diffusivity of plastic particle [m2 s-1]\n",
    "    d_a = k * (t + 273.16)/(6. * math.pi * sw_visc * r_a)     # diffusivity of algal cells [m2 s-1] \n",
    "    beta_abrown = 4.*math.pi*(d_pl + d_a)*(r_tot + r_a)       # Brownian motion [m3 s-1] \n",
    "    beta_ashear = 1.3*gamma*((r_tot + r_a)**3.)               # advective shear [m3 s-1]\n",
    "    beta_aset = (1./2.)*math.pi*r_tot**2. * abs(vs)           # differential settling [m3 s-1]\n",
    "    beta_a = beta_abrown + beta_ashear + beta_aset            # collision rate [m3 s-1]\n",
    "    \n",
    "    a_coll = (beta_a*aa)/theta_pl\n",
    "    a_growth = mu_aa*a\n",
    "    a_mort = m_a*a\n",
    "    a_resp = (q10**((t-20.)/10.))*r20*a     \n",
    "    \n",
    "    particle.a += (a_coll + a_growth - a_mort - a_resp) * particle.dt\n",
    "\n",
    "    dn = 2. * (r_tot)                             # equivalent spherical diameter [m]\n",
    "    delta_rho = (rho_tot - rho_sw)/rho_sw         # normalised difference in density between total plastic+bf and seawater[-]        \n",
    "    d = ((rho_tot - rho_sw) * g * dn**3.)/(rho_sw * kin_visc**2.) # [-]\n",
    "    \n",
    "    if dn > 5e9:\n",
    "        w = 1000.\n",
    "    elif dn <0.05:\n",
    "        w = (d**2.) *1.71E-4\n",
    "    else:\n",
    "        w = 10.**(-3.76715 + (1.92944*math.log10(d)) - (0.09815*math.log10(d)**2.) - (0.00575*math.log10(d)**3.) + (0.00056*math.log10(d)**4.))\n",
    "    \n",
    "    if z >= 4000.: \n",
    "        vs = 0\n",
    "    elif z < 1. and delta_rho < 0:\n",
    "        vs = 0  \n",
    "    elif delta_rho > 0:\n",
    "        vs = (g * kin_visc * w * delta_rho)**(1./3.)\n",
    "    else: \n",
    "        a_del_rho = delta_rho*-1.\n",
    "        vs = -1.*(g * kin_visc * w * a_del_rho)**(1./3.)  # m s-1\n",
    "\n",
    "    particle.depth += vs * particle.dt \n",
    "    particle.vs = vs\n",
    "    z = particle.depth\n",
    "    dt = particle.dt\n",
    "\n",
    "\"\"\" Defining the fieldset\"\"\" # FOR NOW: only 1 day (05 01 2007), and time_extrapolation = True\n",
    "\n",
    "dirread = '/projects/0/topios/hydrodynamic_data/NEMO-MEDUSA/ORCA0083-N006/means/'\n",
    "dirread_bgc = '/projects/0/topios/hydrodynamic_data/NEMO-MEDUSA_BGC/ORCA0083-N006/means/'  \n",
    "dirread_mesh = '/projects/0/topios/hydrodynamic_data/NEMO-MEDUSA/ORCA0083-N006/domain/'  \n",
    "\n",
    "ufiles = (dirread+'ORCA0083-N06_20070105d05U.nc')\n",
    "vfiles = (dirread+'ORCA0083-N06_20070105d05V.nc')\n",
    "wfiles = (dirread+'ORCA0083-N06_20070105d05W.nc')\n",
    "pfiles = (dirread_bgc+'ORCA0083-N06_20070105d05P.nc')\n",
    "ppfiles = (dirread_bgc+'ORCA0083-N06_20070105d05D.nc')\n",
    "tsfiles = (dirread+'ORCA0083-N06_20070105d05T.nc')\n",
    "mesh_mask = dirread_mesh+'coordinates.nc'\n",
    "\n",
    "filenames = {'U': {'lon': mesh_mask, 'lat': mesh_mask, 'depth': wfiles, 'data': [ufiles]},\n",
    "             'V': {'lon': mesh_mask, 'lat': mesh_mask, 'depth': wfiles, 'data': [vfiles]},\n",
    "             'W': {'lon': mesh_mask, 'lat': mesh_mask, 'depth': wfiles, 'data': [wfiles]},\n",
    "             'd_phy': {'lon': mesh_mask, 'lat': mesh_mask, 'depth': wfiles, 'data': pfiles},\n",
    "             'nd_phy': {'lon': mesh_mask, 'lat': mesh_mask, 'depth': wfiles, 'data': pfiles},             \n",
    "             #'tpp': {'lon': mesh_mask, 'lat': mesh_mask, 'depth': wfiles, 'data': ppfiles}, # AAmu\n",
    "             'cons_temperature': {'lon': mesh_mask, 'lat': mesh_mask, 'depth': wfiles, 'data': tsfiles},\n",
    "             'abs_salinity': {'lon': mesh_mask, 'lat': mesh_mask, 'depth': wfiles, 'data': tsfiles}}\n",
    "\n",
    "\n",
    "variables = {'U': 'uo',\n",
    "             'V': 'vo',\n",
    "             'W': 'wo',\n",
    "             'd_phy': 'PHD',\n",
    "             'nd_phy': 'PHN',\n",
    "             #'tpp': 'TPP3', # AAmu\n",
    "             'cons_temperature': 'potemp',\n",
    "             'abs_salinity': 'salin'}\n",
    "\n",
    "dimensions = {'U': {'lon': 'glamf', 'lat': 'gphif', 'depth': 'depthw', 'time': 'time_centered'},\n",
    "              'V': {'lon': 'glamf', 'lat': 'gphif', 'depth': 'depthw', 'time': 'time_centered'},\n",
    "              'W': {'lon': 'glamf', 'lat': 'gphif', 'depth': 'depthw', 'time': 'time_centered'},\n",
    "              'd_phy': {'lon': 'glamf', 'lat': 'gphif', 'depth': 'depthw','time': 'time_centered'},\n",
    "              'nd_phy': {'lon': 'glamf', 'lat': 'gphif', 'depth': 'depthw','time': 'time_centered'},\n",
    "              #'tpp': {'lon': 'glamf', 'lat': 'gphif', 'depth': 'depthw','time': 'time_centered'}, # AAmu\n",
    "              'cons_temperature': {'lon': 'glamf', 'lat': 'gphif', 'depth': 'depthw','time': 'time_centered'},\n",
    "              'abs_salinity': {'lon': 'glamf', 'lat': 'gphif', 'depth': 'depthw','time': 'time_centered'}}\n",
    "\n",
    "#t = xr.open_dataset(mesh_mask)\n",
    "#test = t.variables['nav_lev'] \n",
    "#print(test)\n",
    "initialgrid_mask = dirread+'ORCA0083-N06_20070105d05U.nc'\n",
    "mask = xr.open_dataset(initialgrid_mask, decode_times=False)\n",
    "Lat, Lon, Depth = mask.variables['nav_lat'], mask.variables['nav_lon'], mask.variables['depthu']\n",
    "latvals = Lat[:]; lonvals = Lon[:] # extract lat/lon values to numpy arrays\n",
    "\n",
    "iy_min, ix_min = getclosest_ij(latvals, lonvals, minlat, minlon)\n",
    "#iy_max, ix_max = getclosest_ij(latvals, lonvals, maxlat, maxlon)\n",
    "iy_max = iy_min+3\n",
    "ix_max = ix_min+3\n",
    "\n",
    "indices = {'lon': range(ix_min, ix_max), 'lat': range(iy_min, iy_max)}  # 'depth': range(0, 2000)\n",
    "\n",
    "fieldset = FieldSet.from_nemo(filenames, variables, dimensions, allow_time_extrapolation=True,indices=indices)\n",
    "\n",
    "lons = fieldset.U.lon\n",
    "lats = fieldset.U.lat\n",
    "depths = fieldset.U.depth\n",
    "\n",
    "with open('/home/dlobelle/Kooi_project/data/Kooi_input/profiles.pickle', 'rb') as f:\n",
    "    depth,T_z,S_z,rho_z,upsilon_z,mu_z = pickle.load(f)\n",
    "\n",
    "kv_or = np.transpose(np.tile(np.array(upsilon_z),(len(lats),len(lons),1,1)), (2,3,0,1)) # kinematic viscosity\n",
    "sv_or = np.transpose(np.tile(np.array(mu_z),(len(lats),len(lons),1,1)), (2,3,0,1)) # dynamic viscosity of seawater    \n",
    "\n",
    "KV = Field('KV',kv_or,lon=lons,lat=lats,depth = depths, mesh='spherical')#,fieldtype='U'\n",
    "SV = Field('SV',sv_or,lon=lons,lat=lats,depth = depths, mesh='spherical')#,fieldtype='V'\n",
    "        \n",
    "fieldset.add_field(KV)\n",
    "fieldset.add_field(SV)\n",
    "\n",
    "# ------------- Testing using average diatom or non-diatom PP instead of TPP3 -----------\n",
    "\n",
    "pp_orig = xr.open_dataset(ppfiles)\n",
    "euph_z,nd_phy_ml,d_phy_ml = pp_orig.variables['MED_XZE'], pp_orig.variables['PRN'], pp_orig.variables['PRD']\n",
    "\n",
    "z_all = Depth.data # depth levels of NEMO \n",
    "euph_z1 = euph_z[:,iy_min+1,ix_min+1].data #50 # selecting euph layer depth where particle released\n",
    "tot_phy_ml = nd_phy_ml[:,iy_min+1,ix_min+1].data + d_phy_ml[:,iy_min+1,ix_min+1].data \n",
    "id_ = z_all < euph_z1\n",
    "\n",
    "nemo_euph = z_all[id_]\n",
    "\n",
    "dz = np.zeros(len(z_all))\n",
    "for z in range(len(nemo_euph)+1):\n",
    "    dz[z] = (z_all[z+1]-z_all[z])\n",
    "\n",
    "e1 = np.tile(np.array(euph_z1),(1,len(z_all),3,3))\n",
    "p1 = np.tile(np.array(tot_phy_ml),(1,len(z_all),3,3))\n",
    "i1 = np.transpose(np.tile(id_,(3,3,1,1)),(2,3,0,1))\n",
    "dz1 = np.transpose(np.tile(dz,(3,3,1,1)),(2,3,0,1))\n",
    "tpp_or= (p1*i1)/dz1\n",
    "\n",
    "\n",
    "tpp = Field('tpp',tpp_or,lon=lons,lat=lats,depth = depths, mesh='spherical')#,fieldtype='U'\n",
    "        \n",
    "fieldset.add_field(tpp)\n",
    "\n",
    "\n",
    "\"\"\" Defining the particle set \"\"\"\n",
    "\n",
    "pset = ParticleSet.from_list(fieldset=fieldset,       # the fields on which the particles are advected\n",
    "                             pclass=plastic_particle, # the type of particles (JITParticle or ScipyParticle)\n",
    "                             lon= lons[1,1], #-160.,  # a vector of release longitudes \n",
    "                             lat=lats[1,1], #36., \n",
    "                             time = [0],\n",
    "                             depth = [1.])\n",
    "\n",
    "\"\"\" Kernal + Execution\"\"\"\n",
    "\n",
    "kernels = pset.Kernel(AdvectionRK4_3D) + pset.Kernel(polyTEOS10_bsq) + pset.Kernel(Profiles) + pset.Kernel(Kooi) #+ pset.Kernel(Sink) # pset.Kernel(AdvectionRK4_3D_vert) \n",
    "\n",
    "dirwrite = '/home/dlobelle/Kooi_project/data/Kooi_output/tests/'\n",
    "outfile = dirwrite + 'Kooi+NEMO_3D_rho'+str(int(rho_pl))+'_r'+ r_pl+'_'+str(simdays)+'days_'+str(secsdt)+'dtsecs_'+str(hrsoutdt)+'hrsoutdt'\n",
    "\n",
    "pfile= ParticleFile(outfile, pset, outputdt=delta(hours = hrsoutdt)) #120\n",
    "\n",
    "pset.execute(kernels, runtime=delta(days=simdays), dt=delta(seconds = secsdt), output_file=pfile, verbose_progress=True, recovery={ErrorCode.ErrorOutOfBounds: DeleteParticle}) # minutes=0.1\n",
    "pfile.close()\n",
    "\n",
    "print('Execution finished')\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
